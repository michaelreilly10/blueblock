<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boss Battler 2.0</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; background: black; }
        #score, #level, #bossHealth, #pauseButton {
            position: absolute;
            top: 10px;
            color: #00aaff;
            font-size: 20px;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }

        #score { left: 10px; }
        #level { left: 50%; transform: translateX(-50%); }
        #bossHealth { right: 10px; color: #ff4444; }
        #pauseButton { 
            left: 10px; 
            top: 40px;
            cursor: pointer;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        #pauseButton:hover {
            background: rgba(0, 170, 255, 0.5);
        }

        #gameOver, #levelComplete, #pauseMenu, #winScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00aaff;
        }

        #gameOver h1, #levelComplete h1, #pauseMenu h1, #winScreen h1 {
            font-size: 60px;
            margin: 0;
            animation: pulse 1.5s infinite;
            color: #ff4444;
        }

        #winScreen h1 {
            color: #4CAF50;
            text-shadow: 0 0 10px #4CAF50;
        }

        #pauseMenu h1 {
            color: #00aaff;
            animation: none;
        }

        #gameOver p, #levelComplete p, #pauseMenu p, #winScreen p {
            font-size: 24px;
            margin: 10px 0 20px;
            color: white;
        }

        .menu-button {
            font-size: 24px;
            padding: 10px 20px;
            margin: 10px;
            background: #00aaff;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            min-width: 150px;
        }

        .menu-button:hover {
            background: #ffaa00;
            transform: scale(1.05);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes victory {
            0% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
            25% { transform: translate(-50%, -50%) rotate(5deg) scale(1.05); }
            50% { transform: translate(-50%, -50%) rotate(-5deg) scale(1.1); }
            75% { transform: translate(-50%, -50%) rotate(5deg) scale(1.05); }
            100% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
        }

        .victory-animation {
            animation: victory 2s infinite;
        }
        
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        
        #loadingBar {
            width: 300px;
            height: 20px;
            border: 2px solid #00aaff;
            margin-top: 20px;
        }
        
        #loadingProgress {
            height: 100%;
            width: 0%;
            background: #00aaff;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h1>BOSS BATTLER 2.0</h1>
        <p>Loading assets...</p>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
    </div>

    <div id="score">Score: 0</div>
    <div id="pauseButton">Pause</div>
    <div id="level">Level: 1</div>
    <div id="bossHealth">Boss Health: 100</div>
    
    <div id="gameOver">
        <h1>Game Over</h1>
        <p>Your Score: <span id="finalScore">0</span></p>
        <button class="menu-button" id="restart">Restart</button>
        <button class="menu-button" id="menuFromGameOver">Menu</button>
    </div>
    
    <div id="levelComplete">
        <h1>Level Complete!</h1>
        <p>Get ready for the next level...</p>
    </div>
    
    <div id="winScreen">
        <h1>You Win!</h1>
        <h3>You Saved Blocky Planet!</h3>
        <p>Final Score: <span id="winScore">0</span></p>
        <button class="menu-button" id="restartFromWin">Play Again</button>
        <button class="menu-button" id="menuFromWin">Menu</button>
    </div>
    
    <div id="pauseMenu">
        <h1>Paused</h1>
        <p>Game is paused</p>
        <button class="menu-button" id="resume">Resume</button>
        <button class="menu-button" id="menuFromPause">Menu</button>
        <button class="menu-button" id="restartFromPause">Restart</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>

    <audio id="shootSound" src="pew.wav"></audio>
    <audio id="explosionSound" src="bomb.wav"></audio>
    <audio id="bossHitSound" src="boss_hit.wav"></audio>
    <audio id="gameOverSound" src="gameover.wav"></audio>
    <audio id="levelCompleteSound" src="level_complete.wav"></audio>
    <audio id="victorySound" src="victory.wav"></audio>
    <audio id="pauseSound" src="pause.wav"></audio>

    <script>
        // Asset loader
        const assets = {
            images: {
                player: "player.jpg",
                boss1: "max.jpg",
                boss2: "kevin.jpg",
                boss3: "yoden.jpg",
                boss4: "jake.jpg",
                boss5: "boss5.jpg",
                minion1: "minion1.jpg",
                minion2: "minion2.jpg",
                clone: "clone.jpg"
            },
            audio: {
                shoot: "pew.wav",
                explosion: "bomb.wav",
                bossHit: "boss_hit.wav",
                gameOver: "gameover.wav",
                levelComplete: "level_complete.wav",
                victory: "victory.wav",
                pause: "pause.wav"
            }
        };

        const loadedAssets = {
            images: {},
            audio: {}
        };

        let totalAssets = 0;
        let loadedAssetsCount = 0;

        // Count total assets to load
        for (const type in assets) {
            for (const asset in assets[type]) {
                totalAssets++;
            }
        }

        // Update loading progress
        function updateProgress() {
            const progress = (loadedAssetsCount / totalAssets) * 100;
            document.getElementById('loadingProgress').style.width = `${progress}%`;
            
            if (loadedAssetsCount === totalAssets) {
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    initGame();
                }, 500);
            }
        }

        // Load images
        for (const image in assets.images) {
            const img = new Image();
            img.src = assets.images[image];
            img.onload = () => {
                loadedAssets.images[image] = img;
                loadedAssetsCount++;
                updateProgress();
            };
            img.onerror = () => {
                console.error(`Failed to load image: ${assets.images[image]}`);
                // Fallback to colored rectangle if image fails to load
                loadedAssets.images[image] = null;
                loadedAssetsCount++;
                updateProgress();
            };
        }

        // Load audio
        for (const sound in assets.audio) {
            const audio = new Audio();
            audio.src = assets.audio[sound];
            audio.oncanplaythrough = () => {
                loadedAssets.audio[sound] = audio;
                loadedAssetsCount++;
                updateProgress();
            };
            audio.onerror = () => {
                console.error(`Failed to load audio: ${assets.audio[sound]}`);
                loadedAssets.audio[sound] = null;
                loadedAssetsCount++;
                updateProgress();
            };
        }

        function initGame() {
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            const scoreDisplay = document.getElementById("score");
            const levelDisplay = document.getElementById("level");
            const bossHealthDisplay = document.getElementById("bossHealth");
            const gameOverScreen = document.getElementById("gameOver");
            const levelCompleteScreen = document.getElementById("levelComplete");
            const winScreen = document.getElementById("winScreen");
            const pauseMenu = document.getElementById("pauseMenu");
            const finalScoreDisplay = document.getElementById("finalScore");
            const winScoreDisplay = document.getElementById("winScore");
            const pauseButton = document.getElementById("pauseButton");
            const restartButton = document.getElementById("restart");
            const menuFromGameOver = document.getElementById("menuFromGameOver");
            const restartFromWin = document.getElementById("restartFromWin");
            const menuFromWin = document.getElementById("menuFromWin");
            const resumeButton = document.getElementById("resume");
            const menuFromPause = document.getElementById("menuFromPause");
            const restartFromPause = document.getElementById("restartFromPause");

            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Game objects
            let player = { 
                x: canvas.width / 2, 
                y: canvas.height - 100, 
                width: 50, 
                height: 50,
                speed: 0,
                maxSpeed: 7,
                acceleration: 0.2,
                deceleration: 0.1,
                projectiles: []
            };
            
            let bosses = [];
            let bossProjectiles = [];
            let currentLevel = 1;
            let score = 0;
            let gameRunning = true;
            let gamePaused = false;
            let levelTransition = false;
            let transitionTimer = 0;
            const transitionDuration = 2000;
            const levelTransitionDelay = 1500;
            let transitionTimeout = null;
            let keys = {};
            
            // Shooting cooldown
            let canShoot = true;
            const shootCooldown = 200;
            let lastShotTime = 0;
            
            // Starfield background
            const stars = [];
            const starCount = 200;
            
            // Initialize stars
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 + 0.5,
                    speed: Math.random() * 0.2 + 0.05,
                    twinkleSpeed: Math.random() * 0.05 + 0.01,
                    opacity: Math.random(),
                    direction: Math.random() > 0.5 ? 1 : -1
                });
            }

            // Explosion effects
            const explosions = [];
            
            class Explosion {
                constructor(x, y, size) {
                    this.x = x;
                    this.y = y;
                    this.size = size;
                    this.particles = [];
                    this.duration = 30;
                    this.frame = 0;
                    
                    const particleCount = size * 2;
                    for (let i = 0; i < particleCount; i++) {
                        this.particles.push({
                            x: 0,
                            y: 0,
                            size: Math.random() * 3 + 1,
                            speed: Math.random() * 5 + 2,
                            angle: Math.random() * Math.PI * 2,
                            color: `hsl(${Math.random() * 60 + 10}, 100%, 50%)`
                        });
                    }
                }
                
                update() {
                    this.frame++;
                    return this.frame < this.duration;
                }
                
                draw() {
                    const progress = this.frame / this.duration;
                    const currentSize = this.size * (1 - progress * 0.7);
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    this.particles.forEach(particle => {
                        const distance = particle.speed * this.frame;
                        ctx.fillStyle = particle.color;
                        ctx.globalAlpha = 1 - progress;
                        ctx.beginPath();
                        ctx.arc(
                            Math.cos(particle.angle) * distance,
                            Math.sin(particle.angle) * distance,
                            particle.size,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    });
                    
                    ctx.fillStyle = `rgba(255, 200, 0, ${1 - progress})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, currentSize * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
                    gradient.addColorStop(0, `rgba(255, 100, 0, ${0.7 * (1 - progress)})`);
                    gradient.addColorStop(1, "rgba(255, 100, 0, 0)");
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            function drawHealthBar(x, y, width, height, currentHealth, maxHealth) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.fillRect(x, y, width, height);
                
                const healthWidth = (currentHealth / maxHealth) * width;
                ctx.fillStyle = currentHealth > maxHealth * 0.6 ? "#4CAF50" : 
                               currentHealth > maxHealth * 0.3 ? "#FFC107" : "#F44336";
                ctx.fillRect(x, y, healthWidth, height);
                
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, width, height);
            }
            
            function drawStars() {
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                stars.forEach(star => {
                    if (!gamePaused) {
                        star.y += star.speed;
                    }
                    
                    if (star.y > canvas.height) {
                        star.y = 0;
                        star.x = Math.random() * canvas.width;
                    }
                    
                    star.opacity += star.twinkleSpeed * star.direction;
                    if (star.opacity > 1 || star.opacity < 0.3) {
                        star.direction *= -1;
                    }
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function togglePause() {
                gamePaused = !gamePaused;
                if (gamePaused) {
                    pauseMenu.style.display = "block";
                    if (loadedAssets.audio.pause) loadedAssets.audio.pause.play();
                } else {
                    pauseMenu.style.display = "none";
                }
            }

            function goToMenu() {
                window.location.href = "menu.html";
            }

            function startLevelTransition() {
                clearTimeout(transitionTimeout);
                
                levelTransition = true;
                transitionTimer = 0;
                levelCompleteScreen.style.display = "block";
                if (loadedAssets.audio.levelComplete) loadedAssets.audio.levelComplete.play();

                player.x = canvas.width / 2;
                player.y = canvas.height - 100;

                player.projectiles = [];
                bossProjectiles = [];
            }

            function showWinScreen() {
                gameRunning = false;
                winScreen.style.display = "block";
                winScoreDisplay.textContent = score;
                if (loadedAssets.audio.victory) loadedAssets.audio.victory.play();
                winScreen.classList.add("victory-animation");
            }

            pauseButton.addEventListener("click", togglePause);
            resumeButton.addEventListener("click", togglePause);
            menuFromPause.addEventListener("click", goToMenu);
            menuFromGameOver.addEventListener("click", goToMenu);
            menuFromWin.addEventListener("click", goToMenu);
            restartFromPause.addEventListener("click", () => {
                location.reload();
            });
            restartFromWin.addEventListener("click", () => {
                location.reload();
            });

            window.addEventListener("keydown", (e) => {
                if (gamePaused) return;
                
                if (e.key === " " && canShoot) {
                    const currentTime = Date.now();
                    if (currentTime - lastShotTime >= shootCooldown) {
                        player.projectiles.push(new Projectile(player.x + player.width / 2, player.y));
                        if (loadedAssets.audio.shoot) loadedAssets.audio.shoot.play();
                        canShoot = false;
                        lastShotTime = currentTime;
                        
                        setTimeout(() => {
                            canShoot = true;
                        }, shootCooldown);
                    }
                } else {
                    keys[e.key] = true;
                }
            });

            window.addEventListener("keyup", (e) => {
                if (e.key === " ") {
                    // Spacebar released
                } else {
                    keys[e.key] = false;
                }
            });

            window.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    togglePause();
                }
            });
        
            class Boss {
                constructor(level) {
                    this.level = level;
                    this.maxHealth = level === 5 ? 250 : (level === 4 ? 300 : (level === 3 ? 200 : (level === 2 ? 200 : 100)));
                    this.health = this.maxHealth;
                    this.width = 100 + (level - 1) * 20;
                    this.height = 100 + (level - 1) * 20;
                    this.x = canvas.width / 2 - this.width / 2;
                    this.y = 50;
                    this.speed = 2 + (level - 1) * 0.5;
                    this.attackPattern = level % 5;
                    this.shootCooldown = level === 3 ? 70 : (level === 5 ? 30 : (level === 4 ? 60 : (level === 2 ? 80 : 100)));
                    this.shootTimer = 0;
                    this.directionY = 1;
                    this.directionX = 1;
                    this.moveTimer = 0;
                    this.moveCooldown = 60;
                    this.oscillationFactor = 0;
                    this.bigShotCooldown = 180;
                    this.bigShotTimer = 0;
                    
                    if (level === 1) {
                        this.directionX = Math.random() < 0.5 ? 1 : -1;
                        this.directionY = Math.random() < 0.5 ? 1 : -1;
                    }
                    
                    if (level === 2) {
                        this.phase = 0;
                        this.phaseTimer = 0;
                        this.clones = [];
                        this.splitCooldown = 180;
                        this.splitTimer = 0;
                    }
                    
                    if (level === 3) {
                        this.phase = 0;
                        this.phaseTimer = 0;
                        this.minions = [];
                        this.chargingBigShot = false;
                        this.chargeTimer = 0;
                    }
                    
                    if (level === 5) {
                        this.phase = 0;
                        this.phaseTimer = 0;
                        this.minions = [];
                        this.laserCharge = 0;
                        this.laserActive = false;
                        this.laserWidth = 0;
                    }
                }
        
                update() {
                    if (gamePaused) return;
                    
                    if (this.level === 1) {
                        this.moveTimer++;
                        if (this.moveTimer >= this.moveCooldown) {
                            this.moveTimer = 0;
                            this.directionX = Math.random() < 0.5 ? 1 : -1;
                            this.directionY = Math.random() < 0.5 ? 1 : -1;
                        }
        
                        this.x += this.speed * this.directionX;
                        this.y += this.speed * this.directionY;
        
                        if (this.x + this.width > canvas.width) {
                            this.x = canvas.width - this.width;
                            this.directionX = -1;
                        } else if (this.x < 0) {
                            this.x = 0;
                            this.directionX = 1;
                        }
        
                        if (this.y + this.height > canvas.height / 2) {
                            this.y = canvas.height / 2 - this.height;
                            this.directionY = -1;
                        } else if (this.y < 0) {
                            this.y = 0;
                            this.directionY = 1;
                        }
                    } else if (this.level === 2) {
                        this.phaseTimer++;
                        this.splitTimer++;
                        
                        if (this.phase === 0) {
                            this.x += Math.sin(this.phaseTimer * 0.05) * 2;
                            this.y += Math.cos(this.phaseTimer * 0.03) * 1.5;
                            
                            this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                            this.y = Math.max(50, Math.min(canvas.height/2, this.y));
                            
                            if (this.splitTimer >= this.splitCooldown) {
                                this.splitTimer = 0;
                                this.phase = 1;
                                this.createClones();
                            }
                        }
                        else if (this.phase === 1) {
                            if (this.phaseTimer > 120) {
                                this.phase = 0;
                                this.phaseTimer = 0;
                            }
                        }
                        
                        this.clones.forEach((clone, index) => {
                            clone.update();
                            if (clone.health <= 0) {
                                this.clones.splice(index, 1);
                                score += 20;
                                explosions.push(new Explosion(
                                    clone.x + clone.width/2,
                                    clone.y + clone.height/2,
                                    Math.max(clone.width, clone.height)
                                ));
                                if (loadedAssets.audio.explosion) loadedAssets.audio.explosion.play();
                            }
                        });
                    } else if (this.level === 3) {
                        this.phaseTimer++;
                        this.bigShotTimer++;
                        
                        this.oscillationFactor += 0.04;
                        this.x = canvas.width/2 + Math.cos(this.oscillationFactor) * 150;
                        this.y = canvas.height/3 + Math.sin(this.oscillationFactor) * 100;
                        
                        if (this.phaseTimer % 180 === 0) {
                            this.summonMinion();
                        }
                        
                        if (this.bigShotTimer >= this.bigShotCooldown) {
                            this.bigShotTimer = 0;
                            this.fireBigProjectile();
                        }
                        
                        this.minions.forEach((minion, index) => {
                            minion.update();
                            if (minion.health <= 0) {
                                this.minions.splice(index, 1);
                                score += 30;
                                explosions.push(new Explosion(
                                    minion.x + minion.width/2,
                                    minion.y + minion.height/2,
                                    Math.max(minion.width, minion.height) * 1.5
                                ));
                                if (loadedAssets.audio.explosion) loadedAssets.audio.explosion.play();
                            }
                        });
                    } else if (this.level === 4) {
                        this.oscillationFactor += 0.03;
                        this.x = canvas.width/2 + Math.cos(this.oscillationFactor) * (canvas.width/3 - this.width/2);
                        this.y = canvas.height/3 + Math.sin(this.oscillationFactor) * (canvas.height/4);
                        
                        this.moveTimer++;
                        if (this.moveTimer >= this.moveCooldown) {
                            this.moveTimer = 0;
                            this.oscillationFactor = Math.random() * Math.PI * 2;
                        }
                    } else if (this.level === 5) {
                        this.phaseTimer++;
                        
                        if (this.phase === 0) {
                            this.oscillationFactor += 0.02;
                            this.x = canvas.width/2 + Math.cos(this.oscillationFactor) * 200;
                            this.y = canvas.height/3 + Math.sin(this.oscillationFactor * 1.5) * 100;
                            
                            // Summon one minion at start of phase
                            if (this.phaseTimer === 1) {
                                this.summonMinion();
                            }
                            
                            if (this.phaseTimer > 240) {
                                this.phase = 1;
                                this.phaseTimer = 0;
                            }
                        }
                        else if (this.phase === 1) {
                            this.x = canvas.width/2 - this.width/2;
                            this.y = canvas.height/4;
                            
                            // Summon one minion at start of phase
                            if (this.phaseTimer === 1) {
                                this.summonMinion();
                            }
                            
                            if (this.phaseTimer % 30 === 0) {
                                this.createCircleAttack();
                            }
                            
                            if (this.phaseTimer > 180) {
                                this.phase = 2;
                                this.phaseTimer = 0;
                                this.laserCharge = 0;
                            }
                        }
                        else if (this.phase === 2) {
                            // Summon one minion at start of phase
                            if (this.phaseTimer === 1) {
                                this.summonMinion();
                            }
                            
                            if (!this.laserActive) {
                                this.laserCharge++;
                                if (this.laserCharge > 90) {
                                    this.laserActive = true;
                                    this.laserWidth = 50;
                                }
                            } 
                            else {
                                this.laserWidth = Math.min(this.laserWidth + 2, 300);
                                if (this.phaseTimer > 120) {
                                    this.laserActive = false;
                                    this.phase = 0;
                                    this.phaseTimer = 0;
                                }
                            }
                        }
                        
                        this.minions.forEach((minion, index) => {
                            minion.update();
                            if (minion.health <= 0) {
                                this.minions.splice(index, 1);
                                score += 50;
                                explosions.push(new Explosion(
                                    minion.x + minion.width/2,
                                    minion.y + minion.height/2,
                                    Math.max(minion.width, minion.height) * 1.5
                                ));
                                if (loadedAssets.audio.explosion) loadedAssets.audio.explosion.play();
                            }
                        });
                    }
        
                    this.shootTimer++;
                    if (this.shootTimer >= this.shootCooldown) {
                        this.shootTimer = 0;
                        if (this.level === 1) {
                            bossProjectiles.push(new BossProjectile(
                                this.x + this.width / 2, 
                                this.y + this.height, 
                                5, 5, Math.PI / 2
                            ));
                        } else if (this.level === 2) {
                            if (this.phase === 0) {
                                for (let i = 0; i < 3; i++) {
                                    const angle = Math.PI/2 + (i-1) * Math.PI/8;
                                    bossProjectiles.push(new BossProjectile(
                                        this.x + this.width/2,
                                        this.y + this.height,
                                        5, 4, angle
                                    ));
                                }
                            } else if (this.phase === 1) {
                                this.clones.forEach(clone => {
                                    for (let i = 0; i < 4; i++) {
                                        const angle = i * Math.PI/2 + Math.PI/4;
                                        bossProjectiles.push(new BossProjectile(
                                            clone.x + clone.width/2,
                                            clone.y + clone.height/2,
                                            4, 3, angle
                                        ));
                                    }
                                });
                            }
                        } else if (this.level === 3) {
                            for (let i = 0; i < 2; i++) {
                                const angle = this.oscillationFactor * 3 + (i * Math.PI);
                                const proj = new BossProjectile(
                                    this.x + this.width/2,
                                    this.y + this.height/2,
                                    6, 4, angle
                                );
                                proj.color = "#ff6600";
                                bossProjectiles.push(proj);
                            }
                        } else if (this.level === 4) {
                            for (let i = 0; i < 3; i++) {
                                const angle = this.oscillationFactor * 2 + (i * Math.PI * 2 / 3);
                                const proj = new BossProjectile(
                                    this.x + this.width/2,
                                    this.y + this.height/2,
                                    6, 4, angle
                                );
                                proj.tracking = true;
                                proj.color = "#66f2ff";
                                bossProjectiles.push(proj);
                            }
                        } else if (this.level === 5) {
                            if (this.phase === 0) {
                                for (let i = 0; i < 3; i++) {
                                    const angle = this.oscillationFactor * 2 + (i * Math.PI * 2 / 3);
                                    bossProjectiles.push(new BossProjectile(
                                        this.x + this.width/2, 
                                        this.y + this.height/2, 
                                        5, 4, angle
                                    ));
                                }
                            } else if (this.phase === 1) {
                                for (let i = 0; i < 8; i++) {
                                    const angle = (i * Math.PI * 2) / 8;
                                    const proj = new BossProjectile(
                                        this.x + this.width/2,
                                        this.y + this.height/2,
                                        6, 3, angle
                                    );
                                    proj.homing = true;
                                    bossProjectiles.push(proj);
                                }
                            }
                        }
                    }
                }
                
                fireBigProjectile() {
                    if (this.level === 3) {
                        const angleToPlayer = Math.atan2(
                            player.y - this.y, 
                            player.x - this.x
                        );
                        const bigProj = new BossProjectile(
                            this.x + this.width/2,
                            this.y + this.height/2,
                            20,
                            3,
                            angleToPlayer
                        );
                        bigProj.color = "#ff3300";
                        bossProjectiles.push(bigProj);
                    }
                }
        
                createClones() {
                    if (this.level === 2) {
                        for (let i = 0; i < 2; i++) {
                            const clone = {
                                x: this.x + (i === 0 ? -50 : 50),
                                y: this.y + 30,
                                width: this.width * 0.7,
                                height: this.height * 0.7,
                                maxHealth: 30,
                                health: 30,
                                speed: 2.5,
                                angle: Math.random() * Math.PI * 2,
                                update: function() {
                                    if (gamePaused) return;
                                    this.angle += 0.02;
                                    this.x += Math.cos(this.angle) * this.speed;
                                    this.y += Math.sin(this.angle) * this.speed;
                                    
                                    this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                                    this.y = Math.max(50, Math.min(canvas.height/1.5, this.y));
                                },
                                draw: function() {
                                    if (loadedAssets.images.clone) {
                                        ctx.drawImage(loadedAssets.images.clone, this.x, this.y, this.width, this.height);
                                    } else {
                                        // Fallback if image didn't load
                                        ctx.fillStyle = "rgba(150, 255, 150, 0.7)";
                                        ctx.beginPath();
                                        ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                    
                                    drawHealthBar(
                                        this.x + this.width/2 - 30, 
                                        this.y - 15, 
                                        60, 
                                        5, 
                                        this.health, 
                                        this.maxHealth
                                    );
                                }
                            };
                            this.clones.push(clone);
                        }
                    }
                }
        
                summonMinion() {
                    if (this.level === 3 || this.level === 5) {
                        const minion = {
                            x: this.x + this.width/2,
                            y: this.y + this.height,
                            width: this.level === 3 ? 40 : 50,
                            height: this.level === 3 ? 40 : 50,
                            maxHealth: this.level === 3 ? 20 : 30,
                            health: this.level === 3 ? 20 : 30,
                            speed: this.level === 3 ? 1.5 : 2,
                            angle: Math.random() * Math.PI * 2,
                            shootTimer: 0,
                            shootCooldown: this.level === 3 ? 120 : 180,
                            update: function() {
                                if (gamePaused) return;
                                this.x += Math.cos(this.angle) * this.speed;
                                this.y += Math.sin(this.angle) * this.speed;
                                
                                if (this.x < 0 || this.x > canvas.width) {
                                    this.angle = Math.PI - this.angle;
                                }
                                if (this.y < 50 || this.y > (this.level === 3 ? canvas.height/1.5 : canvas.height/2)) {
                                    this.angle = -this.angle;
                                }
                                
                                // Level 3 minions shoot at player
                                if (this.level === 3) {
                                    this.shootTimer++;
                                    if (this.shootTimer >= this.shootCooldown) {
                                        this.shootTimer = 0;
                                        const angleToPlayer = Math.atan2(
                                            player.y - this.y, 
                                            player.x - this.x
                                        );
                                        bossProjectiles.push(new BossProjectile(
                                            this.x + this.width/2, this.y + this.height/2, 4, 4, angleToPlayer
                                        ));
                                    }
                                }
                                
                                // Level 5 minions occasionally shoot
                                if (this.level === 5 && Math.random() < 0.01) {
                                    const angleToPlayer = Math.atan2(
                                        player.y - this.y, 
                                        player.x - this.x
                                    );
                                    bossProjectiles.push(new BossProjectile(
                                        this.x + this.width/2, this.y + this.height/2, 4, 4, angleToPlayer
                                    ));
                                }
                            },
                            draw: function() {
                                const minionImage = this.level === 3 ? loadedAssets.images.minion1 : loadedAssets.images.minion2;
                                if (minionImage) {
                                    ctx.drawImage(minionImage, this.x, this.y, this.width, this.height);
                                } else {
                                    // Fallback if image didn't load
                                    ctx.fillStyle = this.level === 3 ? "#ff6666" : "green";
                                    ctx.beginPath();
                                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Add a "gun" indicator for shooting minions
                                    if (this.level === 3) {
                                        ctx.fillStyle = "black";
                                        const gunAngle = Math.atan2(
                                            player.y - this.y, 
                                            player.x - this.x
                                        );
                                        ctx.beginPath();
                                        ctx.arc(
                                            this.x + this.width/2 + Math.cos(gunAngle) * this.width * 0.4,
                                            this.y + this.height/2 + Math.sin(gunAngle) * this.height * 0.4,
                                            this.width * 0.15,
                                            0,
                                            Math.PI * 2
                                        );
                                        ctx.fill();
                                    }
                                }
                                
                                drawHealthBar(
                                    this.x + this.width/2 - 20, 
                                    this.y - 15, 
                                    40, 
                                    4, 
                                    this.health, 
                                    this.maxHealth
                                );
                            },
                            level: this.level
                        };
                        this.minions.push(minion);
                    }
                }
        
                createCircleAttack() {
                    if (this.level === 5) {
                        for (let i = 0; i < 12; i++) {
                            const angle = (i * Math.PI * 2) / 12;
                            const proj = new BossProjectile(
                                this.x + this.width/2,
                                this.y + this.height/2,
                                8, 3, angle
                            );
                            proj.homing = true;
                            bossProjectiles.push(proj);
                        }
                    }
                }
        
                draw() {
                    const bossImage = loadedAssets.images[`boss${this.level}`];
                    
                    if (bossImage) {
                        // Draw boss image
                        if (this.level === 2 && this.phase === 1) {
                            ctx.globalAlpha = 0.3;
                        }
                        
                        ctx.drawImage(bossImage, this.x, this.y, this.width, this.height);
                        ctx.globalAlpha = 1.0;
                    } else {
                        // Fallback drawing if image didn't load
                        if (this.level === 1) {
                            ctx.fillStyle = "rgba(255, 100, 100, 0.8)";
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = "white";
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/3, this.y + this.height/3, this.width/8, 0, Math.PI * 2);
                            ctx.arc(this.x + this.width*2/3, this.y + this.height/3, this.width/8, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.strokeStyle = "white";
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/4, 0.1 * Math.PI, 0.9 * Math.PI);
                            ctx.stroke();
                        } else if (this.level === 2) {
                            if (this.phase === 0) {
                                ctx.fillStyle = "rgba(100, 255, 100, 0.8)";
                                ctx.beginPath();
                                ctx.arc(
                                    this.x + this.width/2, 
                                    this.y + this.height/2, 
                                    this.width/2, 
                                    0, 
                                    Math.PI * 2
                                );
                                ctx.fill();
                                
                                ctx.fillStyle = "#00ff00";
                                ctx.beginPath();
                                ctx.arc(
                                    this.x + this.width/2, 
                                    this.y + this.height/2, 
                                    this.width/4, 
                                    0, 
                                    Math.PI * 2
                                );
                                ctx.fill();
                            } else {
                                ctx.fillStyle = "rgba(100, 255, 100, 0.3)";
                                ctx.beginPath();
                                ctx.arc(
                                    this.x + this.width/2, 
                                    this.y + this.height/2, 
                                    this.width/2, 
                                    0, 
                                    Math.PI * 2
                                );
                                ctx.fill();
                            }
                        } else if (this.level === 3) {
                            ctx.fillStyle = "rgba(255, 100, 0, 0.8)";
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = "#ffff00";
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (this.level === 4) {
                            ctx.fillStyle = "rgba(100, 100, 255, 0.8)";
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = "#66f2ff";
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (this.level === 5) {
                            ctx.fillStyle = "rgba(200, 0, 200, 0.8)";
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            const colors = ["#00ffff", "#ffff00", "#ff0000"];
                            ctx.fillStyle = colors[this.phase];
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            if (this.laserActive) {
                                ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
                                ctx.fillRect(
                                    this.x + this.width/2 - this.laserWidth/2, 
                                    this.y + this.height,
                                    this.laserWidth,
                                    canvas.height - this.y - this.height
                                );
                            }
                        }
                    }
                    
                    // Draw health bar
                    const healthBarWidth = this.level === 5 ? 150 : 100;
                    const healthBarHeight = this.level === 5 ? 10 : 8;
                    const healthBarYOffset = this.level === 5 ? 25 : 20;
                    
                    drawHealthBar(
                        this.x + this.width/2 - healthBarWidth/2, 
                        this.y - healthBarYOffset, 
                        healthBarWidth, 
                        healthBarHeight, 
                        this.health, 
                        this.maxHealth
                    );
                    
                    // Draw minions/clones
                    if (this.level === 2) {
                        this.clones.forEach(clone => clone.draw());
                    }
                    
                    if (this.level === 3 || this.level === 5) {
                        this.minions.forEach(minion => minion.draw());
                    }
                }
            }
        
            class BossProjectile {
                constructor(x, y, size, speed, angle) {
                    this.x = x;
                    this.y = y;
                    this.size = size;
                    this.speed = speed;
                    this.angle = angle;
                    this.tracking = false;
                    this.trackingTimer = 0;
                    this.color = "orange";
                    this.homing = false;
                    this.homingTimer = 0;
                }
        
                update() {
                    if (gamePaused) return;
                    
                    if (this.tracking && this.trackingTimer < 90) {
                        this.trackingTimer++;
                        const targetAngle = Math.atan2(
                            player.y - this.y,
                            player.x - this.x
                        );
                        this.angle = this.angle * 0.97 + targetAngle * 0.03;
                    }
                    
                    if (this.homing && this.homingTimer < 60) {
                        this.homingTimer++;
                        const targetAngle = Math.atan2(
                            player.y - this.y,
                            player.x - this.x
                        );
                        this.angle = this.angle * 0.95 + targetAngle * 0.05;
                    }
                    
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                }
        
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        
            bosses.push(new Boss(currentLevel));
        
            class Projectile {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.size = 5;
                    this.speed = 10;
                }
        
                update() {
                    if (gamePaused) return;
                    this.y -= this.speed;
                }
        
                draw() {
                    ctx.fillStyle = "yellow";
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        
            function updatePlayer() {
                if (gamePaused) return;
                
                if (keys["ArrowLeft"]) {
                    player.speed = Math.max(player.speed - player.acceleration, -player.maxSpeed);
                } else if (keys["ArrowRight"]) {
                    player.speed = Math.min(player.speed + player.acceleration, player.maxSpeed);
                } else {
                    if (player.speed > 0) {
                        player.speed = Math.max(player.speed - player.deceleration, 0);
                    } else if (player.speed < 0) {
                        player.speed = Math.min(player.speed + player.deceleration, 0);
                    }
                }
        
                player.x += player.speed;
        
                if (player.x < 0) {
                    player.x = 0;
                    player.speed = 0;
                } else if (player.x > canvas.width - player.width) {
                    player.x = canvas.width - player.width;
                    player.speed = 0;
                }
            }
        
            function checkCollision(a, b) {
                return a.x < b.x + b.width &&
                       a.x + a.width > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.height > b.y;
            }
        
            function update() {
                if (!gameRunning || gamePaused) return;
        
                if (levelTransition) {
                    transitionTimer += 16;
                    if (transitionTimer >= transitionDuration) {
                        levelTransition = false;
                        levelCompleteScreen.style.display = "none";
                        if (currentLevel <= 5) {
                            bosses.push(new Boss(currentLevel));
                        }
                    }
                    return;
                }
        
                for (let i = explosions.length - 1; i >= 0; i--) {
                    if (!explosions[i].update()) {
                        explosions.splice(i, 1);
                    }
                }
        
                updatePlayer();
        
                bosses.forEach((boss, bossIndex) => {
                    boss.update();
        
                    player.projectiles.forEach((projectile, pIndex) => {
                        if (boss.phase !== 1 && checkCollision(projectile, boss)) {
                            boss.health -= 10;
                            score += 10;
                            if (loadedAssets.audio.bossHit) loadedAssets.audio.bossHit.play();
                            player.projectiles.splice(pIndex, 1);
        
                            if (boss.health <= 0) {
                                explosions.push(new Explosion(
                                    boss.x + boss.width/2,
                                    boss.y + boss.height/2,
                                    Math.max(boss.width, boss.height) * 1.5
                                ));
                                if (loadedAssets.audio.explosion) loadedAssets.audio.explosion.play();
                                
                                bosses.splice(bossIndex, 1);
                                score += 100 * currentLevel;
                                
                                transitionTimeout = setTimeout(() => {
                                    currentLevel++;
                                    if (currentLevel <= 5) {
                                        startLevelTransition();
                                    } else {
                                        showWinScreen();
                                    }
                                }, levelTransitionDelay);
                            }
                        }
                        
                        if (boss.level === 2) {
                            boss.clones.forEach((clone, cloneIndex) => {
                                if (checkCollision(projectile, clone)) {
                                    clone.health -= 10;
                                    score += 10;
                                    player.projectiles.splice(pIndex, 1);
                                }
                            });
                        }
                        
                        if (boss.level === 3 || boss.level === 5) {
                            boss.minions.forEach((minion, minionIndex) => {
                                if (checkCollision(projectile, minion)) {
                                    minion.health -= 10;
                                    score += 10;
                                    player.projectiles.splice(pIndex, 1);
                                }
                            });
                        }
                    });
        
                    if (checkCollision(player, boss)) {
                        gameRunning = false;
                        gameOverScreen.style.display = "block";
                        finalScoreDisplay.textContent = score;
                        if (loadedAssets.audio.gameOver) loadedAssets.audio.gameOver.play();
                        clearTimeout(transitionTimeout);
                    }
        
                    if (boss.level === 3 || boss.level === 5) {
                        boss.minions.forEach(minion => {
                            if (checkCollision(player, minion)) {
                                gameRunning = false;
                                gameOverScreen.style.display = "block";
                                finalScoreDisplay.textContent = score;
                                if (loadedAssets.audio.gameOver) loadedAssets.audio.gameOver.play();
                                clearTimeout(transitionTimeout);
                            }
                        });
                    }
                    
                    if (boss.level === 2) {
                        boss.clones.forEach(clone => {
                            if (checkCollision(player, clone)) {
                                gameRunning = false;
                                gameOverScreen.style.display = "block";
                                finalScoreDisplay.textContent = score;
                                if (loadedAssets.audio.gameOver) loadedAssets.audio.gameOver.play();
                                clearTimeout(transitionTimeout);
                            }
                        });
                    }
                    
                    // Check for laser collision (level 5 boss)
                    if (boss.level === 5 && boss.laserActive) {
                        const laserLeft = boss.x + boss.width/2 - boss.laserWidth/2;
                        const laserRight = boss.x + boss.width/2 + boss.laserWidth/2;
                        
                        if (player.x + player.width > laserLeft && 
                            player.x < laserRight && 
                            player.y < boss.y + boss.height) {
                            
                            gameRunning = false;
                            gameOverScreen.style.display = "block";
                            finalScoreDisplay.textContent = score;
                            if (loadedAssets.audio.gameOver) loadedAssets.audio.gameOver.play();
                            clearTimeout(transitionTimeout);
                        }
                    }
                });
        
                bossProjectiles.forEach((projectile, index) => {
                    projectile.update();
        
                    if (checkCollision(player, projectile)) {
                        gameRunning = false;
                        gameOverScreen.style.display = "block";
                        finalScoreDisplay.textContent = score;
                        if (loadedAssets.audio.gameOver) loadedAssets.audio.gameOver.play();
                        clearTimeout(transitionTimeout);
                    }
        
                    if (projectile.y > canvas.height || projectile.x < 0 || projectile.x > canvas.width) {
                        bossProjectiles.splice(index, 1);
                    }
                });
        
                player.projectiles.forEach((projectile, index) => {
                    projectile.update();
                    if (projectile.y < 0) {
                        player.projectiles.splice(index, 1);
                    }
                });
        
                scoreDisplay.textContent = "Score: " + score;
                levelDisplay.textContent = "Level: " + currentLevel;
                if (bosses.length > 0) {
                    bossHealthDisplay.textContent = "Boss Health: " + bosses[0].health;
                }
                
                if (transitionTimeout && !levelTransition) {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.font = "30px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText("LEVEL CLEAR!", canvas.width/2, 100);
                }
            }
        
            function draw() {
                drawStars();
        
                explosions.forEach(explosion => explosion.draw());
                
                // Draw player
                if (loadedAssets.images.player) {
                    ctx.drawImage(loadedAssets.images.player, player.x, player.y, player.width, player.height);
                } else {
                    // Fallback if player image didn't load
                    ctx.fillStyle = "blue";
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }
        
                bosses.forEach(boss => boss.draw());
        
                bossProjectiles.forEach(projectile => projectile.draw());
                player.projectiles.forEach(projectile => projectile.draw());
            }
        
            function gameLoop() {
                if (gameRunning) {
                    update();
                    draw();
                    requestAnimationFrame(gameLoop);
                }
            }
        
            restartButton.addEventListener("click", () => {
                location.reload();
            });
        
            menuFromGameOver.addEventListener("click", goToMenu);
        
            gameLoop();
        }
    </script>
</body>
</html>